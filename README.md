# Core-JavaScript-Fundamentals

#Functions


## **تابع (Function) در جاوا اسکریپت چیست؟**  

در **جاوا اسکریپت**، **تابع (Function)** مجموعه‌ای از کدها است که **یک کار خاص را انجام می‌دهد**. توابع به شما کمک می‌کنند که **کدها را سازمان‌دهی کنید، از تکرار جلوگیری کنید، و کدها را خواناتر و قابل استفاده مجدد کنید**.

---

## **📌 نحوه تعریف تابع در جاوا اسکریپت**  
### **۱. تابع معمولی (Function Declaration)**
```js
function greet() {
    console.log("سلام! به جاوا اسکریپت خوش آمدی.");
}
greet(); // فراخوانی تابع
```
✅ در این روش، تابع را با **کلمه کلیدی `function`** تعریف می‌کنیم.  
✅ این تابع را می‌توان **قبل از تعریف آن** فراخوانی کرد، چون **هوئیست (Hoisting)** می‌شود.

---

### **۲. تابع با پارامتر (Parameters)**
پارامترها متغیرهایی هستند که **به تابع مقدار ورودی می‌دهند**.

```js
function greetUser(name) {
    console.log("سلام " + name + "!");
}
greetUser("علی"); // خروجی: سلام علی!
greetUser("مریم"); // خروجی: سلام مریم!
```
✅ در اینجا تابع **`greetUser`** یک پارامتر **`name`** دریافت می‌کند و مقدار ورودی را چاپ می‌کند.

---

### **۳. تابع با مقدار بازگشتی (`return`)**
تابع می‌تواند مقدار **برگرداند** و از آن در جای دیگری استفاده شود.

```js
function sum(a, b) {
    return a + b;
}
let result = sum(5, 10); // مقدار بازگشتی در متغیر ذخیره می‌شود
console.log(result); // خروجی: 15
```
✅ `return` مقدار را برمی‌گرداند و آن را ذخیره یا استفاده می‌کنیم.  
✅ اگر `return` نداشته باشد، مقدار `undefined` برمی‌گردد.

---------------------------------------------------------------------------------------------------
---------------------------------------------------------------------------------------------------








#Closures & Scope

### **تفاوت `var`، `let` و `const` در جاوا اسکریپت**  

در جاوا اسکریپت، برای تعریف متغیرها از `var`، `let` و `const` استفاده می‌شود. اما این سه تفاوت‌هایی در **حوزه‌ی دسترسی (Scope)**، **هوئیستینگ (Hoisting)** و **قابلیت تغییر مقدار (Reassignment)** دارند.  

---

## **1. تفاوت در حوزه‌ی دسترسی (Scope)**  

### **🔹 `var` – دارای حوزه‌ی **تابع (Function Scope)****  
- متغیرهای تعریف شده با `var` فقط در داخل تابعی که در آن تعریف شده‌اند، قابل دسترسی هستند.  
- اگر `var` را بیرون از یک تابع تعریف کنید، به یک **متغیر سراسری (Global Variable)** تبدیل می‌شود.  
- `var` **دارای حوزه‌ی بلاک نیست**، یعنی درون `{}` (مثل `if` یا `for`) محدود نمی‌شود.  

✅ **مثال: `var` به بلاک محدود نمی‌شود**  
```js
function testVar() {
    if (true) {
        var x = 10;  // `x` داخل این بلاک تعریف شده
    }
    console.log(x); // ✅ اما همچنان در دسترس است!
}
testVar();
```
🚨 **مشکل:** متغیرهای `var` ممکن است ناخواسته از بلاک خارج شوند و باعث خطا شوند.  

---

### **🔹 `let` – دارای حوزه‌ی **بلاک (Block Scope)****  
- `let` **فقط در همان بلاک `{}` که تعریف شده قابل دسترسی است**.  
- برخلاف `var`، مقدار آن **خارج از بلاک در دسترس نیست**.  

✅ **مثال: `let` محدود به بلاک است**  
```js
function testLet() {
    if (true) {
        let y = 20; // `y` فقط داخل این بلاک در دسترس است
    }
    console.log(y); // ❌ خطا: y تعریف نشده است
}
testLet();
```
🚀 **نتیجه:** `let` از نشت متغیرها جلوگیری می‌کند و از `var` امن‌تر است.  

---

### **🔹 `const` – دارای حوزه‌ی بلاک و مقدار تغییرناپذیر**  
- `const` مانند `let` **در همان بلاک `{}` محدود می‌شود**.  
- اما **نمی‌توان مقدار آن را تغییر داد** پس یک **متغیر ثابت** است.  
- **نکته:** **اگر `const` یک آرایه یا شیء باشد، محتوای داخل آن می‌تواند تغییر کند!**  

✅ **مثال: `const` مقدارش تغییر نمی‌کند، اما شیء داخل آن بله!**  
```js
const z = 30;
z = 40; // ❌ خطا: مقدار ثابت تغییر نمی‌کند

const person = { name: "Ali" };
person.name = "Reza"; // ✅ شیء داخل `const` را می‌توان تغییر داد
console.log(person.name); // "Reza"
```

---

## **2. تفاوت در هوئیستینگ (Hoisting)**  
### **🔹 `var` هوئیست می‌شود اما مقدار اولیه `undefined` است**  
- متغیرهای `var` هنگام اجرا **به بالای کد برده می‌شوند (Hoisting)** ولی مقدار اولیه ندارند.  

✅ **مثال: `var` هوئیست می‌شود ولی مقدارش `undefined` است**  
```js
console.log(a); // undefined (نه خطا، ولی مقدار ندارد)
var a = 5;
```

### **🔹 `let` و `const` هوئیست می‌شوند اما مقداردهی نمی‌شوند**  
- این دو نیز **به بالا برده می‌شوند اما قبل از مقداردهی قابل استفاده نیستند**.  
- این وضعیت **"منطقه‌ی مرده‌ی موقت" (Temporal Dead Zone - TDZ)** نامیده می‌شود.  

🚨 **مثال: `let` و `const` قبل از مقداردهی خطا می‌دهند**  
```js
console.log(b); // ❌ ReferenceError: Cannot access 'b' before initialization
let b = 10;
```

---

## **3. تفاوت در قابلیت تغییر مقدار (Reassignment)**
| نوع متغیر   | حوزه‌ی دسترسی (Scope) | هوئیست (Hoisting) | قابلیت تغییر مقدار | قابلیت تعریف دوباره |
|-------------|----------------------|-------------------|---------------------|--------------------|
| `var`       | تابع (Function)       | بله ✅             | بله ✅              | بله ✅             |
| `let`       | بلاک (Block)          | خیر ❌            | بله ✅              | خیر ❌            |
| `const`     | بلاک (Block)          | خیر ❌            | خیر ❌ (ولی اشیاء تغییر می‌کنند) | خیر ❌ |

---

## **🚀 نتیجه‌گیری: کدام را استفاده کنیم؟**
✅ **`const` را همیشه استفاده کنید** مگر این که نیاز به تغییر مقدار داشته باشید.  
✅ **`let` را زمانی استفاده کنید** که مقدار متغیر تغییر خواهد کرد.  
❌ **`var` را استفاده نکنید** مگر این که با کد قدیمی کار می‌کنید.  







#Dom Manipulation

get Element by ID

### **انتخاب عناصر با `getElementById` در جاوا اسکریپت**  

متد **`document.getElementById("id")`** یکی از رایج‌ترین روش‌ها برای انتخاب عناصر HTML است. این متد **فقط یک عنصر** را برمی‌گرداند، چون `id` در یک صفحه‌ی وب باید **منحصربه‌فرد** باشد.  

---

## **📌 نحوه استفاده از `getElementById`**  

```js
const element = document.getElementById("myElement");
```
- **`myElement`** باید مقدار **id** یک عنصر HTML باشد.  
- اگر **چنین `id`ای وجود نداشته باشد، مقدار `null` برمی‌گردد.  

✅ **مثال ۱: انتخاب و تغییر متن یک عنصر**  
```html
<h1 id="title">سلام دنیا!</h1>
<script>
    const title = document.getElementById("title"); // انتخاب عنصر <h1>
    title.textContent = "سلام جاوا اسکریپت!"; // تغییر متن عنصر
</script>
```

---

## **📌 تغییر استایل با `getElementById`**  

✅ **مثال ۲: تغییر رنگ متن و پس‌زمینه**  
```html
<p id="text">این یک متن است.</p>
<button onclick="changeColor()">تغییر رنگ</button>

<script>
    function changeColor() {
        const text = document.getElementById("text"); // انتخاب <p>
        text.style.color = "red"; // تغییر رنگ متن به قرمز
        text.style.backgroundColor = "yellow"; // پس‌زمینه زرد
    }
</script>
```

---

## **📌 افزودن یا حذف کلاس‌های CSS**  
✅ **مثال ۳: اضافه کردن کلاس به یک عنصر**  
```html
<p id="message">این پیام است.</p>
<button onclick="addClass()">اضافه کردن کلاس</button>

<style>
    .highlight { color: white; background-color: blue; padding: 10px; }
</style>

<script>
    function addClass() {
        const msg = document.getElementById("message");
        msg.classList.add("highlight"); // اضافه کردن کلاس "highlight"
    }
</script>
```

---

## **📌 حذف یک عنصر از صفحه**  
✅ **مثال ۴: حذف یک عنصر با `remove()`**  
```html
<p id="paragraph">این یک متن است که حذف خواهد شد.</p>
<button onclick="removeElement()">حذف کردن</button>

<script>
    function removeElement() {
        const paragraph = document.getElementById("paragraph");
        paragraph.remove(); // حذف عنصر از صفحه
    }
</script>
```

---

## **📌 بررسی وجود `id` در صفحه**
اگر `id`ای که جستجو می‌کنید وجود نداشته باشد، مقدار `null` برمی‌گردد، که اگر مستقیماً به ویژگی‌های آن دسترسی داشته باشید، باعث خطا می‌شود.

✅ **راه حل: بررسی مقدار `null` قبل از استفاده**  
```js
const element = document.getElementById("unknownId");
if (element) {
    element.textContent = "متن تغییر کرد!";
} else {
    console.log("عنصر یافت نشد.");
}
```

---

## **🚀 نتیجه‌گیری**
✅ `getElementById` **یک روش سریع و کارآمد** برای انتخاب عناصر خاص است.  
✅ فقط **یک عنصر برمی‌گرداند** و برای `id`های یکتا در صفحه مناسب است.  
✅ می‌توان از آن برای **تغییر محتوا، استایل، حذف و اضافه کردن کلاس‌ها** استفاده کرد.  

